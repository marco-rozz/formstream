// Code generated by MockGen. DO NOT EDIT.
// Source: condition_judger.go
//
// Generated by this command:
//
//	mockgen -source=condition_judger.go -destination=mock/condition_judger.go -package=mock
//

// Package mock is a generated GoMock package.
package mock

import (
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockIConditionJudger is a mock of IConditionJudger interface.
type MockIConditionJudger[K comparable, S any, T any] struct {
	ctrl     *gomock.Controller
	recorder *MockIConditionJudgerMockRecorder[K, S, T]
}

// MockIConditionJudgerMockRecorder is the mock recorder for MockIConditionJudger.
type MockIConditionJudgerMockRecorder[K comparable, S any, T any] struct {
	mock *MockIConditionJudger[K, S, T]
}

// NewMockIConditionJudger creates a new mock instance.
func NewMockIConditionJudger[K comparable, S any, T any](ctrl *gomock.Controller) *MockIConditionJudger[K, S, T] {
	mock := &MockIConditionJudger[K, S, T]{ctrl: ctrl}
	mock.recorder = &MockIConditionJudgerMockRecorder[K, S, T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIConditionJudger[K, S, T]) EXPECT() *MockIConditionJudgerMockRecorder[K, S, T] {
	return m.recorder
}

// HookEvent mocks base method.
func (m *MockIConditionJudger[K, S, T]) HookEvent(key K, value S) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HookEvent", key, value)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HookEvent indicates an expected call of HookEvent.
func (mr *MockIConditionJudgerMockRecorder[K, S, T]) HookEvent(key, value any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HookEvent", reflect.TypeOf((*MockIConditionJudger[K, S, T])(nil).HookEvent), key, value)
}

// IsHookExist mocks base method.
func (m *MockIConditionJudger[K, S, T]) IsHookExist(key K) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsHookExist", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsHookExist indicates an expected call of IsHookExist.
func (mr *MockIConditionJudgerMockRecorder[K, S, T]) IsHookExist(key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsHookExist", reflect.TypeOf((*MockIConditionJudger[K, S, T])(nil).IsHookExist), key)
}

// KeyEvent mocks base method.
func (m *MockIConditionJudger[K, S, T]) KeyEvent(key K) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "KeyEvent", key)
	ret0, _ := ret[0].(error)
	return ret0
}

// KeyEvent indicates an expected call of KeyEvent.
func (mr *MockIConditionJudgerMockRecorder[K, S, T]) KeyEvent(key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "KeyEvent", reflect.TypeOf((*MockIConditionJudger[K, S, T])(nil).KeyEvent), key)
}

// MockHook is a mock of Hook interface.
type MockHook[K comparable, S any, T any] struct {
	ctrl     *gomock.Controller
	recorder *MockHookMockRecorder[K, S, T]
}

// MockHookMockRecorder is the mock recorder for MockHook.
type MockHookMockRecorder[K comparable, S any, T any] struct {
	mock *MockHook[K, S, T]
}

// NewMockHook creates a new mock instance.
func NewMockHook[K comparable, S any, T any](ctrl *gomock.Controller) *MockHook[K, S, T] {
	mock := &MockHook[K, S, T]{ctrl: ctrl}
	mock.recorder = &MockHookMockRecorder[K, S, T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHook[K, S, T]) EXPECT() *MockHookMockRecorder[K, S, T] {
	return m.recorder
}

// AbnormalPath mocks base method.
func (m *MockHook[K, S, T]) AbnormalPath(arg0 T) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AbnormalPath", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// AbnormalPath indicates an expected call of AbnormalPath.
func (mr *MockHookMockRecorder[K, S, T]) AbnormalPath(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AbnormalPath", reflect.TypeOf((*MockHook[K, S, T])(nil).AbnormalPath), arg0)
}

// NormalPath mocks base method.
func (m *MockHook[K, S, T]) NormalPath(arg0 S) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NormalPath", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// NormalPath indicates an expected call of NormalPath.
func (mr *MockHookMockRecorder[K, S, T]) NormalPath(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NormalPath", reflect.TypeOf((*MockHook[K, S, T])(nil).NormalPath), arg0)
}

// Requirements mocks base method.
func (m *MockHook[K, S, T]) Requirements() []K {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Requirements")
	ret0, _ := ret[0].([]K)
	return ret0
}

// Requirements indicates an expected call of Requirements.
func (mr *MockHookMockRecorder[K, S, T]) Requirements() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Requirements", reflect.TypeOf((*MockHook[K, S, T])(nil).Requirements))
}
